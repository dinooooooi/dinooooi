▶첫 번째 과제는 파이썬 머신러닝 완벽가이드 pg. 39~86 부분을 스스로 공부한 후, 아래와 같이 과제를 수행하여 제출해주시면 됩니다.

1) 개념부분은 모르겠거나 어려운 부분을 최소 한 소단원 아상 마크다운으로 정리
2) 코드는 모든 소단원 내용을 빠짐없이 필사
3) 깃허브에 업로드 후 카페 게시글에 깃허브 링크 댓글로 달기

▶두 번째 과제는 오늘 세션 때 풀은 넘파이 연습문제를 끝까지(26~39번) 풀고, 깃허브에 업로드 한 뒤, 깃허브 링크를 댓글로 달아주시면 됩니다.

데이터 핸들링- 판다스
파이썬에서 데이터 처리를 위해 존재하는 가장 인기 있는 라이브러리
일반적으로 데이터 세트 : 2차원 데이터 (행*열)
ㄴ 가장 이해하기 쉬운 데이터 구조 & 효과적으로 데이터 담음
판다스 : 2차원 데이터를 효율적으로 가공/처리하는 기능, 넘파이보다 유연하고 편리하게 데이터 핸들링, 고수준 api, csv 등 파일도 쉽게 data frame으로 변경해 데이터의 가공/분석 편리하게 수행
핵심 개체 - dataframe : 여러 개의 행과 열로 이뤄진 2차원 데이터를 담는 데이터 구조체
index : 개별 데이터를 고유하게 식별하는 key값
series -> 칼럼 하나, dataframe -> 칼럼 여러개

판다스 시작 - 파일을 dataframe으로 로딩, 기본 api
pandas를 pd로 에일리어스해 임포트하는 것이 관례!
판다스의 dataframe으로 로딩
read.csv()csv 파일 포맷 변환을 위한 api
read_table() 디폴트 필드 구분 문자는 탭문자
read_csv('파일명', sep='\t')처럼 쓰면 필드 구분 문자 기반의 파일 포맷도 변환 가능
read_fwf() 고정길이 기반의 칼럼 포맷을 dataframe으로 로딩하기 위한 api
dataframe은 데이터, 칼럼의 타입, null 데이터 개수, 데이터 분포도 등의 메타 데이터도 조회 가능
ex) info(), describe()
info() - 총 데이터 건수와 데이터 타입, null 건수
describe() - 칼럼별 숫자형 데이터값의 n-percentile 분포도, 평균값, 최댓값, 최솟값 (숫자형만 가능)
데이터의 분포도 -> 머신러닝 알고리즘의 성능 향상시키는 중요 요소
count : not null인 데이터 건수
mean : 전체 데이터의 평균값
value_counts() -> 많은 건수 순서로 정렬되어 값 변환 dataframe [] 내부에 칼럼명 입력하면 해당 칼럼에 해당하는 series 객체 반환
반환하는 데이터 타입 - series 객체 / 왼 인덱스값, 오 데이터값 / 고유성이 보장되면 의미 있는 데이터값 할당 가능 / 고유 칼럼 값을 식별자로 사용 가능

dataframe과 리스트, 딕셔너리, 넘파이ndarray 상호 변환
numpy ndarray, 파이썬 리스트, 딕셔너리로부터 dataframe 생성
1차원 형태의 데이터를 기반으로 dataframe 생성 -> 칼럼명 지정 해야함 - 1차원 형태의 데이터기반이기 때문에 칼럼명 하나만 필요
2차원 형태의 데이터를 기반으로 dataframe 생성 -> 2행 3열 형태의 리스트와 ndarray 기반이기 때문에 칼럼명 3개 필요
딕셔너리를 변환 -> 딕셔너리의 키는 칼럼명으로 값은 칼럼 데이터로 변환, 키 = 문자열, 값 = 리스트 or ndarray 형태
dataframe을 numpy ndarray, 리스트, 딕셔너리로 변환하기

dataframe의 칼럼 데이터 세트 생성과 수정
새로운 칼럼 age_0을 추가하고 일괄 0값 할당하기

dataframe 데이터 삭제
drop() 메서드 이용 / 원형 : DataFrame.drop(labels=None, axis=0, index=None, columns=None, level=None, inplace=False, errors='raise')
axis값에 따라 특정 갈럼 또는 특정 행 드롭 - axis0=0을 입력하면 로우 축 방향으로 드롭을 수행하므로 이상치 데이터 삭제하는 경우에 사용, 일반적으로는 axis1=0을 입력!
inplace = false 설정 디폴트임 자기자신의 dataframe 데이터는 삭제하지 않음

index 객체
=dataframe, series의 레코드를 고유하게 식별하는 객체
series 객체는 index 객체를 포함하지만 series 객체에 연산 함수를 적용할 때 index는 연산에서 제외됨. index는 오직 식별용
reset_index() 메서드 -> 새롭게 인덱스를 연속 숫자 형으로 할당하며 기존 인덱스는 'index'라는 새로운 칼럼 명으로 추가 / 인덱스가 연속된 int 숫자형 데이터가 아닐 경우에 주로 사용

데이터 셀렉션 및 필터링
dataframe의 []연산자
: 안에 칼럼 명 문자, 인덱스로 변환 가능한 표현식 = 칼럼만 지정할 수 있는 칼럼지정연산자!
넘파이는 안에 행의 위치, 열의 위치, 슬라이싱 범위 등을 지정 가능
dataframe 바로 뒤의 [] 내 입력 값은 칼럼명을 지정해 칼럼 지정 연산에 사용하거나 불른 인덱스 용도로만 사용해야함
dataframe[0:2]와 같은 슬라이싱 연산으로 데이터를 추출하는 방법은 사용하지 않는게 좋음

dataframe ix[] 연산자
: ix[0,'Pclass'] 원하는 위치의 데이터를 추출할 수 있음 dataframe 인덱스값을 입력해야함
열 위치 지정은 칼럼 명이 아닌 칼럼의 위치 값 지정도 가능
but 사라질 예정
loc[] 칼럼 명칭 기반 인덱싱 연산자 & iloc[] 칼럼 위치 기반 인덱싱 연산자가 만들어짐

명칭 기반 인덱싱과 위치 기반 인덱싱의 구분
명칭 기반 인덱싱 : 칼럼의 명칭을 기반으로 위치를 지정하는 방식
위치 기반 인덱싱 : 0을 출발점으로  행, 열 값으로 정수가 입력됨
dataframe의 인덱스값은 명칭 기반 인덱싱으로 간주
iloc[] : 위치 기반 인덱싱만 허용 - 행과 열 값으로 integer 또는 integer형의 슬라이싱, 팬시 리스트 값을 입력
lic[] : 명칭 기반 데이터 추출 - 행에 dataframe index 값, 열에 칼럼 명 입력
슬라이싱 기호 - 시작값~종료값-1
but loc[]에 슬라이싱 기호는 시작값~종료값
why? 명칭 기반 인덱싱이기 때문에

불린 인덱싱
: 데이터 필터링 방식 / 가져올 값의 조건으로 ix[] 내에 입력하면 자동으로 원하는 값을 필터링
[], loc[] 가능, iloc[] 불가능
and 조건 -> & , or 조건 -> |, not 조건 -> ~

정렬, aggregation 함수, groupby 적용
dataframe, series 정렬 - sort_values() 메서드 이용
sort_values(by=[''], ascending=True, inplace=False) 가 기본

aggregation 함수 적용
= min(), max(), sum(), count()
바로 dataframe에 호출하면 모든 칼럼에 적용

groupby() 적용
dataframe에 groupby()를 호출하면 dataframegroupby 라는 또다른 형태의 dataframe을 반환
